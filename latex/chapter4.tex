\chapter{Implementation}
\label{chapter:implementation}

The objective for this chapter is to describe the steps and decisions taken, and the reasoning behind the implemented features. It starts in section \ref{implementation:objectives}, by presenting the objectives for the implementation, following by the used technologies on the several components in section \ref{implementation:technologies}. After that, in sections \ref{implementation:devices} and \ref{implementation:rules}, it is presented the standards used to access the devices and to define rules, respectively. Following, in section \ref{implementation:architecture}, the whole system's architecture, as well as the functionalities of its components, are described. 

Since one of the requirements and objectives for this project was the existence of failure handling mechanisms, in section \ref{implementation:scenarios}, it is described the implementation taking into account the several scenarios addressed in the previous chapter. 

\newpage

\section{Objectives}
\label{implementation:objectives}

Although the implementation of the whole solution, presented in chapter \ref{chapter:architecture}, would be optimal to validate the project, it would be unrealistic due to the amount of time necessary to do so and the limited time available for this dissertation. Since some of the features were already implemented, such as a working platform to create and manage rules, a \ac{cep} engine and a simple gateway to communicate with devices through BLE, this dissertation's main focus was in the implementation of gateways capable of implement automation rules, alike to the ones implemented by the CEP engine, as well as give them means to adapt to failing and emergency states. For that reason, was also implemented a gateway manager to act as a monitor for the gateways. The gateway manager is not only able to control the operation of each gateway, but also, manage the distribution of rules and devices throughout them.

Looking at the architecture presented in chapter 3, the component for the user management dashboard was not implemented for the scope of this work. Apart from this, all the features mentioned were implemented and are detailed in the continuation of this chapter.



\section{Adopted  Technologies}
\label{implementation:technologies}

This section aims to discuss the technologies chosen for the different components of the architecture. These choices will be justified and explained taking into account the requirements for this project. However, it is important to note that there are no perfect solutions and, in some cases, several approaches could have been taken. 

Since there was a dissertation\cite{helder} that already implemented some features like the \ac{cep} engine and the \ac{bm}, some of the technologies used in this dissertation were influenced by past decisions. As far as the \ac{cep} engine concerns, the choice was the WSO2 \ac{cep} \cite{wso2}, since its features addressed all requirements, that such system would need, to fit this project's requirements. For the purpose of this dissertation both the \ac{cep} engine and the \ac{bm} as well as the communication between them, did not affect any of the new implemented features. Since the MQTT protocol was primarily used as the elect protocol for communications in the referred dissertation, the implemented features presented in this work followed the same path.

Finally, it is important to state that the standard used, in SmartLighting project, for both object definition to read and write information to/from devices, and the rules structure, were also maintained and will be described in the following sections. 

\section{Access to Devices}
\label{implementation:devices}

Devices like sensors, which measure environment changes, and actuators, that may trigger mechanisms to make changes in that same environment, are fundamental pieces to implement a smart and automated environment. Since there are a huge variety of devices with different characteristics, in order to enable extensibility for the system, the access to those devices, as well as the messages format, should be standardised. In another dissertation for this project, a standard following the IP Smart Objects Alliance Guideline\cite{IPSOAlliance2014} was made and is illustrated in Figure \ref{fig:obj}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{figures/obj.png}
	\caption{Device objects representation}
	\label{fig:obj}
\end{figure}

In this representation, a device can have multiple objects (sensors and/or actuators), identified through an ID and an object instance. As example, a device can have multiple sensing or actuating capabilities, each one of them identified with a different ID. A device with two motion sensors, will have two objects with the same ID but different object instances. 

Inside the representation of each object, the information is divided in resources. Resources represent the available features that each object provides, such as the available values that can be read or written, or the actions that can be triggered. As an example, an luminaire actuator object can have resources to read the current state of the luminaire, turn  on/off or dim the light to a certain value, each one of them represented with a different ID. The resource instance is used when, per example, an actuator for aluminaire with two lamps offers the same resources for each lamp separately.

Using this representation, the properties of a device can be accessed using an Uniform Resource Identifier (URI) the following way: 


\begin{minted}[
frame=single
]{nginx}

.../Object_ID/Object_Instance/Resource_ID/Resource_Instance
	

\end{minted}
	
For instance, a device with a temperature sensor that offers the possibility to check the current state or check the minimum value measured by the sensor since it is ON, can be illustrated and accessed the following way:


\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{figures/obj2.png}
	\caption{Access to a device resources.}
	\label{fig:obj2}
\end{figure}
	
Since the protocol used for this project was \ac{mqtt}, which allows to subscribe and publish messages in specific topics, this URI can be used in the topic to address each device resource. 


Since the WSO2 \ac{cep} was chosen as the complex event processor for this project\cite{helder}, a message format to communicate with devices, supported by that engine, was chosen. The format is represented in Snippet \ref{snippet:example}.

\begin{listing}[H]
\begin{minted}[
frame=single
]{json}

{
    "event": {
        "metaData": { 
            "attribute_1": ***,
            "attribute_2": ***,
            ...
        },
        "correlationData": {
            "attribute_1": ***,
            "attribute_2": ***,
            ...
        }, 
        "payloadData": {
            "attribute_1": ***, 
            "attribute_2": ***,
        }
    }
}


\end{minted}
\caption{Example of a simplified message for an event sent to a device.}
\label{snippet:example}
\end{listing}

These event messages are divided in three main logical sections: Payload Data, Correlation Data and Meta Data. Payload Data is the most important data to be transported, such as, the values that are sent to and from devices. The Correlation Data transports information that allows correlating events and lastly, the Meta Data is where other attributes that describe the event can be included. In Snippet \ref{snippet:todevice} is represented an example message of an event sent to a device.

\begin{listing}[H]
\begin{minted}[
frame=single
]{json}
{
    "event": {
        "metaData": {
            "operation":"set"
        }, 
        "payloadData": {
            "value": 15 
        }
    } 
}

\end{minted}
\caption{Example of a simplified message for an event sent to a device.}
\label{snippet:todevice}
\end{listing}

This message would set the value 15 on a device's resource, if sent to the corresponding topic using the format presented above.

\section{Rules Standard}
\label{implementation:rules}


To obtain a fully autonomous system, rules must be designed in order to achieve it. In a former work for SmartLighting project\cite{helder}, a solution was designed to, instead of using directly the languages provided by each \ac{cep} engine which are difficult to map using a Graphical User Interface, a more extensible and pluggable solution was created. When a rule is made in the platform, a JSON is generated containing all the information needed to convert the rule to the desired engine, either the WSO2 \ac{cep} engine or the Gateway engine, that will be addressed later.

In this solution, a Rule is divided in Actions, each one containing a Target and a Function. The Target specifies to where the output events, resulting from applying the rule, should be sent, while the Listeners inside the Function specify which input events trigger the rule. Still inside the Function, there can be present four types of modules to transform the event stream: Aggregators, Converters, Windows and Filters. Filters are used to select only events that pass a certain condition, otherwise the rule is not applied. Windows, allow to capture events in a given interval of time or occurrences following some criteria. This module is often used with Aggregators that perform aggregate calculations, such as summing the events or calculating averages. Lastly, the function of Converters is to make calculations with each event, for instance to perform unit conversions. There can also be used the Pattern and Sequence modules that, as the name says, are used to detect patterns or specific sequences of events.


In Snippet \ref{snip:rule} in Appendix A, is shown an example on an output JSON of a rule with a single action. As can be observed, a rule can be constituted by sub rules. Each sub rule within a Rule has the same Function but different Targets and Listeners. In this particular case, the rule has a function called "setif\_value\_percent" with two different types of Listeners, a "listen\_boolean" and a "listen\_value". The first is used to listen to boolean values (which in this case are the motion sensor state) and the last to listen to float values (luminance sensors, in this case). The boolean data is read for a 6 seconds time window and aggregated with the “any” Aggregator which detects if there was any motion in the last 6 seconds. The data containing the luminance values, is aggregated with an average over the last 5 events, and converted using the converter “lux\_to\_percent”. Therefore, the function sends an event to the target with the 100\% calculated percentage, if a motion is detected in the last 6 seconds, or 50\% otherwise. 





	
\section{Architecture}
\label{implementation:architecture}
Taking into consideration the objectives and adopted technologies addressed in chapters \ref{implementation:objectives} and \ref{implementation:technologies}, the implemented architecture is represented in Figure \ref{fig:arch2}. Comparing this architecture to the one presented in Figure \ref{fig:arch}, it is clear the use of MQTT as the main communication protocol, the removal of the User Management component, since it was not in the scope for this dissertation, and, regarding the \ac{cep} engine and the Building Manager, those components were already implemented, as stated before. The BLE Adapter which is part of the gateway was also already implemented. Lastly, the MQTT broker used in this implementation was Mosquitto\footnote{https://mosquitto.org/}, which is a lightweight broker suited for \ac{iot} environments, which implements the latest versions on MQTT protocol. 




\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{figures/architecture3.png}
	\caption{Implementation Architecture}
	\label{fig:arch2}
\end{figure}

For the scope of this dissertation, the focus was the implementation of a Gateway with ability to configure and manage devices, and with a lightweight automation engine that is able to parse rules and process events based on them. It was also implemented a Gateway Manager with features like rule parsing and distribution among gateways and failure handling and synchronization of gateways.

Regarding the failover strategy used, the detection of failures was insured by making every component report its state to the central broker, by publishing a periodic MQTT heart\_beat message. This way, if a fail occurs, the other working nodes are able to detect the absence of the failing node and begin recovering from the fault. All the processes regarding these features are explained next.


\subsection{Gateway Manager}
\label{arch:gm}

This section describes how the Gateway Manager fits in the fulfilment of the requirements and objectives proposed for this project, and also how its features were thought and implemented. 


This component was programmed using Python 3\footnote{https://docs.python.org/3/} and since MQTT was the chosen protocol to communicate with other nodes, the Eclipse Paho MQTT Python client\footnote{https://pypi.python.org/pypi/paho-mqtt/1.3.0} library was used. This client enables the application to connect to a MQTT broker in order to publish messages and subscribe to topics.


\begin{Paragraph}{Rule Parsing and Distribution}
	
One of the Gateway's Manager roles is to receive rules, developed in the existing Building Manager platform. As addressed before, a rule is represented in JSON format, and when the rule is set to be deployed in the gateway's automation engine, the Gateway Manager parses it in order to divide the rule in sub rules and distribute them among the available gateways. To keep track of which rules are deployed where, and to which rule's different targets and listeners correspond, the \ac{gm} attributes a unique ID to each rule and stores, in data structures, the topics(from input and output events) used in each rule and to which rule IDs they correspond, since different rules can have the same targets and/or listeners. These data structures will be important to implement the fail handling measures, which will be addressed later. In Figure \ref{fig:parser_struct}, can be observed the data structure used to store this information. Each entry in the list is a tuple containing a target topic(or listener topic) and a list of rules ID's that contain the same topic.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{figures/parser_struct.png}
	\caption{Data structures used to store Targets and Listeners and to which Rule IDs they correspond.}
	\label{fig:parser_struct}
\end{figure}

After the rule is parsed, the \ac{gm} distribute the sub rules to the available gateways using a round-robin method, in order to maintain a equal number or deployed rules among gateways. This approach was chosen so that gateways can have a balanced load between them. Other approaches could have been implemented, such as distribute rules by proximity to the devices that they refer to, but as downside, there could be gateways with an extensive number of rules that could put in jeopardy the performance and responsiveness of event processing. 

In Figure \ref{fig:addrule} can be observed an interaction diagram of the communication needed to add a new rule to the Gateway Manager and a Subrule to a Gateway, using MQTT.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{figures/addrule.png}
	\caption{Interaction diagram of adding a new rule to the Gateway Manager and a Subrule to a Gateway.}
	\label{fig:addrule}
\end{figure}

As can be observed, the Building Manager publishes a rule and the Gateway Manager parses it in order to divide them into subrules. These subrules are numbered and then distributed to Gateways using the topic(already subscribed in the broker by Gateways) ``/<gw\_hostname>/add\_rule''.

\end{Paragraph}

\begin{Paragraph}{System Awareness}

The \ac{gm}, being the unit that will impose the fail handling measures, needs to be aware of each component and each gateway state. In order to do that, and as addressed before, each component has to send a periodic heart beat message to the central broker, using the ``/heart\_beat'' topic, which is subscribed by the \ac{gm}. The \ac{gm} then checks periodically if every component sent the heart\_beat. If a component fails and it is not able to send the heart\_beat, after a programmable timeout, the \ac{gm} begins the implementation of failing handling measures. These features could have been implemented using Last Will feature of MQTT. Clients could configure a Last Will message, so that upon disconnecting from the broker, due to a failure, that message would be published in the broker and the other nodes would be aware that the faulty node was disconnected. This approach was not implemented so that other protocols, such as COAP(that does not support this feature) could be used, without profound changes in the application's code.

\end{Paragraph}

\begin{Paragraph}{Devices Configuration}

When a new gateway is connected to the system, it sends a message to the \ac{gm}, informing which devices it is able to connect and then, with this information, the \ac{gm} balances the available devices among the gateways. To explain further, when two gateways are able to connect to the same devices, the \ac{gm} balances that devices among the two in order to maintain a equal number of devices in each one. Also, it stores for each device, the gateways that are able to connect to it. This allows that when a gateway fails, the \ac{gm} has the information needed to inform a new gateway, that are able to connected to the lost devices, to take control of those devices.

\end{Paragraph}

\begin{Paragraph}{Gateway Manager Dashboard}

In order to visualize the state of the gateways present in the system, a dashboard was created, using a Python3 web framework, Flask\footnote{http://flask.pocoo.org/}. In Figure \ref{fig:main_gm} is shown the main page of this dashboard.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{figures/main_gm.png}
	\caption{Screenshot of the Gateway Manager dashbord main page.}
	\label{fig:main_gm}
\end{figure}

As can be observed, this dashboard allows to check several information about the gateways, such as, the hostnames, the time of the last heart beat received, the number of devices connected, and has also a feature to turn on/off a gateway if pleased. Also, it has not only the the list of rules and in which gateway they are being deployed, but also a list of devices and the corresponding gateway.


\end{Paragraph}

\begin{Paragraph}{Gateway Failure Handling}
	
Since Gateways are the components that communicate directly with devices, a gateway failure could have a huge impact for the building. For that reason, one of the most important features of the \ac{gm} is to detect that a gateway fails and, as addressed before, inform other gateways within the range of the lost devices to assume control. Also, the rules that were present in the failing gateway, should also be sent to other gateways to be deployed. Bellow in Figure \ref{fig:gwdown}, it is represented the interaction diagram of the processes that occur when a gateway fails. 

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{figures/gwdown.png}
	\caption{Interaction diagram of the procedures when a gateway fails.}
	\label{fig:gwdown}
\end{figure}
	
As can be observed, since the \ac{gm} has the information regarding which gateways have access to which devices, it can easily distribute the lost devices among the gateways that can communicate with them. Also, the rules that were deployed in the lost gateway are distributed through the available gateways using, again, a "round-robin" method in order to balance the number of rules in each gateway.  

\end{Paragraph}

\begin{Paragraph}{Gateways Synchronization}

In some cases, there can be an emergency where the gateways cannot send events nor receive actions through the central \ac{mqtt} Broker. In this state, Gateways must communicate directly with each others. In order to to that, not only they need to know to which gateways they should send its device events to be processed, but also need to know where they must send the processed events to. Since the Gateway Manager has the information regarding the gateways state, i.e, which rules and devices are deployed in each gateway, the \ac{gm} generates, everytime there is a change in either a gateway's devices or rules, two JSON's containing this information and send them to all Gateways. The first JSON contains a list of Listeners \ac{mqtt} topics and for each one, a list of gateways that have process rules for those events. To explain further, when a device generates an event, the corresponding Gateway, uses the information in this JSON to know which gateways are deploying rules that process that event, and send it to each one of them. The second JSON contains a list of Targets and the respective gateways that have devices triggered by that output event. This way, when a gateway finishes the processing of an event, it finds in this list which gateways have devices that are triggered by that event and sends it to them.
 
\end{Paragraph}


\subsection{Gateway}
\label{arch:gw}

This section describes how the Gateway proposed features and its requirements were implemented. Since this project aims to create a smart environment in buildings, the amount of gateways needed to cover the whole network of devices may vary depending on the building size. Most solutions in the \ac{bas} systems rely on expensive gateways which can be a downside for stakeholders. The solution is to create a gateway software that is able to work in a microcontroller or in a small and cheap \ac{soc} like a Raspberry Pi\footnote{https://www.raspberrypi.org/} or a Nano Pi\footnote{http://www.nanopi.org/}. In an initial state, the implementation began to be done using Java, however, the program would consume too much memory, which would be a downside, taking into account the proposed requirements. With this in mind, the programming language used in the deployment of this software was MicroPython\footnote{https://micropython.org/}. MicroPython is an open source Python programming language interpretor that runs on small embedded development boards \cite{micro2} and, although being full packed with advanced features, it is compact enough run within just 256k of code space and 16k of RAM \cite{micro}. For these reasons, MicroPython was chosen to allow more flexibility when choosing gateway's hardware.

To allow the communication between gateways in a scenario where the access to the central \ac{mqtt} broker might be impossible, either due to a failure in the network or in the broker itself, a Mosquitto lightweight MQTT broker was also deployed in each gateway. The use for these brokers will be explained later in section \ref{implementation:scenarios}. Also, since the IP addresses of the several components, which are needed to communicate with each others, can change due to network problems, it was deployed in each node of the system an Avahi \acf{mdns} deamon\footnote{https://www.avahi.org/}, enabling that each component could be reached by just its hostname, which never changes for each machine.


\begin{Paragraph}{Devices Configuration and Management}

When a gateway is deployed, it needs to send, to the \ac{gm} a list of devices within its range and the resources that each device has. Later, the \ac{gm}, responds with a list of which devices should be controlled by the gateway and in which topics should gateways publish events generated by the devices. Also, gateways receive information concerning to which topics they must subscribe in the central broker. To explain further, gateways need to know in which topic to publish events, generated by each device, in the central broker. Also, after those events being processed in the CEP Engine, gateways need to be subscribed to the output event topics that concern the devices it controls, in order to receive the automation actions. Bellow, in Figure \ref{fig:newdevice}, is represented the interaction diagram of the communications needed to configure a new device. 


\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{figures/newdevice.png}
	\caption{Interaction diagram of a new device configuration.}
	\label{fig:newdevice}
\end{figure}


	
\end{Paragraph}
\newpage

\begin{Paragraph}{Rule Parser}

The \ac{gm}, as addressed before, parses the received rules and give an unique ID to each subrule. Then, when balancing the rules among the available gateways, it sends a JSON with the subrule and the given ID. When a sub rule is received in a gateway, it must be deconstructed in order for the automation engine to know which events trigger it, and what actions must be performed. In Figure \ref{fig:parse} it is represented a flow diagram explaining the process of parsing a rule. As addressed before, each subrule can either have a Set Value or a Set Percent Function. In Set Value Functions, there is only one action to be parsed, however, in Set Percent Functions, there are two actions to be considered, a ``Listen\_value'' and a ``Listen\_boolean'' action. For each action, the parser checks the existence of the modules addressed before, i.e. Windows, Aggregators, Filters and Converters, and creates an object for each one of them, containing its informations. An Action object is then created, containing an unique ID and a reference for the modules objects. In the end, the parser saves, in a data structure, the information regarding the rule in the following way: ``Rules[Listeners] = [ActionsID]'', where, Rules is a list of MQTT topics, of the different listeners parsed, and each one of them has a list of ActionsIDs with the same Listener. This was implemented this way so that when an event is received, it is only needed to search for the corresponding Listener topic, in the data structure, to know which actions must be triggered. 


\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\textwidth]{figures/parseRule.png}
	\caption{Rule parser flow diagram}
	\label{fig:parse}
\end{figure}

\end{Paragraph}

\begin{Paragraph}{Gateway Automation Engine}

The \acf{gae}, as stated before, will only work in emergency states, either if the central broker or the \ac{cep} Engine are down. When this happens, gateways subscribe, in the central broker, to the MQTT topics of the listeners present in the rules deployed by each one. This way, the events generated by the devices are published in the broker and then sent to gateways that have rules with those events as input. 

As mentioned earlier, when an event arrives to a gateway, first it must discover the Actions that need to be triggered so that the event can be processed. The \ac{gae} was designed to implement the modules present in Table \ref{module-table}.
 
\begin{table}[H]

	\resizebox{\textwidth}{!}{\begin{tabular}{|c|c|l|}
		\hline
		\textbf{Type}               & \textbf{Module}       & \textbf{Description}                                                                                                                                            \\ \hline
		Listener                    & MQTT                  & MQTT topic to receive events                                                                                                                                     \\ \hline
		Target                      & MQTT                  & MQTT topic to send events                                                                                                                                        \\ \hline
		\multirow{2}{*}{Function}   & Set Value             & Set the value received from input streams to the output streams                                                                                                 \\ \cline{2-3} 
		& Set Percent           & \begin{tabular}[c]{@{}l@{}}Set a percentage of a value from input streams to the output\\ streams, based on boolean data from another input stream\end{tabular} \\ \hline
		\multirow{6}{*}{Filter}     & Equal                 & Filter events with the value equal to a given value                                                                                                             \\ \cline{2-3} 
		& Not Equal             & Filter events with the value different than a given value                                                                                                       \\ \cline{2-3} 
		& Greater Than          & Filter events with the value greater than a given value                                                                                                         \\ \cline{2-3} 
		& Less Than             & Filter events with the value less than a given value                                                                                                            \\ \cline{2-3} 
		& Greater or Equal Than & Filter events with the value greater or equal to a given value                                                                                                  \\ \cline{2-3} 
		& Less or Equal Than    & Filter events with the value less or equal to a given value                                                                                                     \\ \hline
		\multirow{2}{*}{Window}     & Time Window           & Capture events in a predefined time                                                                                                                             \\ \cline{2-3} 
		& Length Window         & Capture a predefined number of events                                                                                                                           \\ \hline
		\multirow{3}{*}{Aggregator} & Average               & Calculate the average value of all the events in a window                                                                                                       \\ \cline{2-3} 
		& Any                   & Returns 1 if any of the values in the window is greater than 0                                                                                                  \\ \cline{2-3} 
		& None                  & Returns 1 if all the values in a window are 0                                                                                                                   \\ \hline
		\multirow{3}{*}{Converter}  & Lux To Percentage     & \begin{tabular}[c]{@{}l@{}}Calculates an output percentage value to apply on a luminaire’s\\ dimming level based on a value in lux units\end{tabular}           \\ \cline{2-3} 
		& Set 1                 & Sets the value to 1                                                                                                                                             \\ \cline{2-3} 
		& Set 0                 & Sets the value to 0                                                                                                                                             \\ \hline
	\end{tabular}}
	\centering
\caption{Implemented modules in Gateway's automation engine.}
\label{module-table}
\end{table}

For each action, the \ac{gae} follows certain steps, as can be visualized in Figure's \ref{fig:action} flow diagram. The first module to be applied is the Filter, if present in the action. If the value present in the event does not pass the filter verification is automatically discarded. After that, the \ac{gae} checks if the action has a window, and as consequence an aggregator, and if so, which type of window and applies it. For instance, with a Time Window with an Any Aggregator, the program must send the value 1 and, if no other event is received within the window time length, the \ac{gae} must send a value 0. If a new event is received within the time window length, the old window is discarded and begins a timer for the new one. Since micropython is a single-threaded programming language, in order to implement features like this one, it had to be used an event pool, in which, each event received is added as a new task for the event pool, and this way, to implement the time window, per example, is only needed to put the task of that event to sleep, the expected time length. Meanwhile the program can run and process other events present in the pool. The implementation of the Time Window module can is represented in Snippet \ref{snippet:rule} in Appendix B. Lastly, the Converter module, if present, processes the value based on the converting rules given and an event is sent to the central broker. 

This automation engine will only be enabled if the \ac{cep} Engine or the central broker fail, as will be addressed and explained later.

\begin{figure}[]
	\centering
	\includegraphics[width=0.6\textwidth]{figures/action.png}
	\caption{Event processing flow diagram.}
	\label{fig:action}
\end{figure}

\end{Paragraph}

\section{Operational Scenarios}
\label{implementation:scenarios}

As one of the most important requirements and objectives for the present dissertation project, the fail handling mechanisms are a core feature for every smart environment deployed in a building. In order to rely with assurance in a fully autonomous system, it must be adapted to answer swiftly to unexpected behaviours within the system. In the scope of this project, the most important component, to impose an autonomous system, is the \ac{cep} engine, however if that component fails, due to internal software failure or a communication failure, the integrity of the building as well as the safety of its occupants could be at risk. For this reason, as addressed before, an automation engine (\ac{gae}) was implemented so that gateways could process events in order to trigger actions.

In section \ref{Architecture:usecases}, were introduced five different operational scenarios: every component working as expected, \ac{cep} Engine down, Gateway Manager down, both CEP Engine and Gateway Manager down, and lastly, the MQTT broker down. For each of these scenarios, it will be explained how the system handle each of the failures in order to maintain the minimum functionalities of the building. 

\begin{Paragraph}{Scenario 1 - All components are operational}
\begin{figure}[H]
	\centering
	\includegraphics[width=0.4\textwidth]{figures/fs1.png}
	\caption{Functioning scenario 1.}
	\label{fig:fs1}
\end{figure}

In scenario 1, as can be observed in Figure \ref{fig:fs1}, all components are working in the expected way. Devices send events to the connected gateways, which forwards them to the central \ac{mqtt} Broker. Then the \ac{cep} Engine process them, based on the deployed rules and publishes the output events on the \ac{mqtt} Broker. Since gateways, as seen before, subscribe to all the topics that concern their devices, they receive the actions and send them to the devices.

In this scenario, the automation engine of the gateways is disabled, since the central \ac{cep} is operational. Finally, this scenario support Gateways failure, since the Gateway Manager is also operational, as it was explained in Figure \ref{fig:gwdown}.

\end{Paragraph}

\begin{Paragraph}{Scenario 2 - \ac{cep} Engine failure}
\begin{figure}[H]
	\centering
	\includegraphics[width=0.4\textwidth]{figures/fs2.png}
	\caption{Functioning scenario 2.}
	\label{fig:fs2}
\end{figure}

In scenario 2, represented in Figure \ref{fig:fs2}, the \ac{cep} Engine is down. As addressed earlier, when this happens, both the Gateways and the Gateway Manager stop receiving its heart beats, and after a configurable timeout (15 seconds in this implementation), gateways subscribe, in the central broker, to the MQTT topics of the listeners present in the rules deployed by each one, and start processing device events. This process is represented in the interaction diagram present in Figure \ref{fig:gae}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{figures/gae.png}
	\caption{Interaction diagram of the processes that take place when \ac{cep} Engine fails.}
	\label{fig:gae}
\end{figure}

Again, this scenario supports failures in gateways, since the Gateway Manager is operational, using the process explained earlier and represented in Figure \ref{fig:gwdown}.

\end{Paragraph}

\begin{Paragraph}{Scenario 3 - Gateway Manager failure}
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.4\textwidth]{figures/fs5.png}
		\caption{Functioning scenario 3.}
		\label{fig:fs5}
	\end{figure}

Scenario 3 represents a failure in the Gateway Manager while all the other components are working correctly. When this happens, the system continues to work correctly, however if a gateway fails while in this scenario, the lost devices and rules will not redistributed to other gateways and thus, the automation of some building areas will stop working. Also, while in this state, no new rules can be added to gateways. Since none of the other components are directly dependent of the Gateway Manager, for its normal operation, its absence will not interfere with the system, and thus, the rest of the nodes can be agnostic about the Gateway Manager state.


\end{Paragraph}



\begin{Paragraph}{Scenario 4 - Gateway Manager and \ac{cep} Engine failure}
\begin{figure}[H]
	\centering
	\includegraphics[width=0.4\textwidth]{figures/fs4.png}
	\caption{Functioning scenario 4.}
	\label{fig:fs4}
\end{figure}

In this scenario, both the Gateway Manager and the \ac{cep} Engine are down. This scenario is detected and produces the same alterations in the system as seen both in scenario 2, as the \ac{cep} Engine failure enables the processing of events in the gateways automation engine, and in scenario 3, as the Gateway Manager failure will disable gateways fail handling and rules distribution.



\end{Paragraph}


\begin{Paragraph}{Scenario 5 - \ac{mqtt} Broker failure}
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.4\textwidth]{figures/fs3.png}
		\caption{Functioning scenario 5.}
		\label{fig:fs3}
	\end{figure}

This last scenario is the most severe and complex one, since if the central \ac{mqtt} broker is down, the communication between gateways and the other components (\ac{gm} and \ac{cep} Engine) is interrupted. When gateways are aware that the central broker is down, the automation engine is enabled, and the events generated by the devices, are sent directly to the brokers of gateways that have rules that process those events. Also, when a gateway receives an event to be processed, it sends the resulting event to gateways that have devices triggered by that event. As seen before, the Gateway Manager synchronizes, between all gateways, the information needed to implement these features: each gateway knows exactly to which gateways the events, of each device it controls, should be sent to be processed, and also, has the information of to which gateways should the processed events be sent. While in this scenario, which could be triggered by a whole building network failure, the gateways would still be able to connect through bluetooth with devices, and thus, the building's most core functionalities, such as lighting, will still be able to work. 

\end{Paragraph}

\begin{Paragraph}{Summary}

	
Looking at the described scenarios, it is noticeable a degradation over the system functionalities. However, regardless the scenario, the most important automation features, that are crucial to the system, can be safeguarded by deploying emergency rules in gateways. Even when core components of the system are down, gateways can still ensure a minimum functionality to the building by themselves. Bellow in Table \ref{summary}, are specified the scenarios, and the component's state and distinctive features present in each one of them.

	
\begin{table}[H]
	\centering
	
		\resizebox{\textwidth}{!}{\begin{tabular}{|c|c|c|c?c|c|c|}
		\hline
		\textbf{Scenarios} & \textbf{Broker} & \textbf{CEP Engine} & \textbf{\begin{tabular}[c]{@{}c@{}}Gateway \\ Manager\end{tabular}} & \textit{\textbf{\begin{tabular}[c]{@{}c@{}}Gw Failure\\ Handling\end{tabular}}} & \textit{\textbf{\begin{tabular}[c]{@{}c@{}}Gw Automation \\ Engine Enabled\end{tabular}}} & \textit{\textbf{\begin{tabular}[c]{@{}c@{}}Gw-Gw \\ Communication\end{tabular}}} \\ \hline
		\textbf{1}         & Up              & Up                  & Up                                                                  & Yes                                                                                  & No                                                                                             & No                                                                               \\ \hline
		\textbf{2}         & Up              & Down                & Up                                                                  & Yes                                                                                  & Yes                                                                                            & No                                                                               \\ \hline
		\textbf{3}         & Up              & Up                  & Down                                                                & No                                                                                   & No                                                                                             & No                                                                               \\ \hline
		\textbf{4}         & Up              & Down                & Down                                                                & No                                                                                   & Yes                                                                                            & No                                                                               \\ \hline
		\textbf{5}         & Down            & N/A                 & N/A                                                                 & No                                                                                   & Yes                                                                                            & Yes                                                                              \\ \hline
	\end{tabular}}
\caption{Scenarios summary table.}
\label{summary}
\end{table}


As can be observed, the gateway's Automation Engine is only enabled either on scenarios where the \ac{cep} Engine is down, or when the broker is unavailable, since it connects gateways to the \ac{cep} Engine. Also, since the Gateway Manager is the component responsible for handling gateway failures as redistribute devices and rules, when this component is down, the gateway's failure handling is not assured. Finally, in scenario 5, since the central broker is down, gateways need to communicate directly with each others in order to insure the processing of its events.

As referred before, the system should be working on scenario 1 the great majority of time, however, since all the other scenarios ensure a basic functionality to the system, a fail in a component would not impose great consequences to the system. Therefore, the implemented features addressed all the requirements and objectives for the proposed dissertation. 

\end{Paragraph}

